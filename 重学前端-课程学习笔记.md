# 重学前端|极客时间
## 前言

## JavaScript
### 关于类型,有哪些你不知道的细节
- 七大类型：Undefined、Null、Boolean、String、Number、Symbol（ES6）、Object。
- 用 void 0 代替 undefined，因为undefined是个变量可以被修改，void计算必定返回undefined
- String有最大长度是 2^53 - 1（UTF16编码）
- Number，IEEE规则，浮点运算精度问题，NaN、Infinity、-Infinity
- Object：是“属性的集合”
- new Number/String/Boolean/Symbol产生Obejct类型，而Number()/S/B/S则产生对应的类型
- Symbol
- JS对于数据转换。装箱转换和拆箱转换。
### 面向对象还是基于对象
- 对象是一种人类认知的高度抽象，JS对象具有高度的动态性
- 数据访问器：getter/setter
- 数据属性四个特征：value, writable, enumerable, configurable
- 定义属性：Object.defineProperty
- 查看属性：Object.getOwnPropertyDescriptor
### 我们真的需要模拟类吗
- JS使用了原型，复制的操作是使得新对象持有一个原型的引用
- JS原型的概括：1.如果所有对象都有私有字段 [[prototype]]，就是对象的原型。2.读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止(原型链)
- Object.create 根据指定的原型创建新对象，原型可以是 null
- Object.getPrototypeOf 获得一个对象的原型
- Object.setPrototypeOf 设置一个对象的原型
- JS中的new操作，两种方式：一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。
- ES6特性class。清除了所有[[class]]相关的私有属性，不会出现new和function搭配的奇怪操作。constructor, extends, getter/setter

### 你知道全部对象的分类吗
- 宿主对象：JS宿主环境提供，浏览器环境的宿主，window
- 内置对象：JS语言提供。固有对象，原生对象，普通对象
- 固有对象是JS代码执行前被创建，类似于基础库（api），“类”是其中一种
- 原生对象，能够通过语言本身的构造器创建的对象。new 创建，拥有许多私有字段。有：Error, Boolean, Number, Data等，无法用class/extend
- 函数对象与构造器对象
- ES6后 => 箭头函数仅用于创建函数，无法当作构造器
- 一些特殊行为的对象：Array, Object.prototype, String, Arguments等

### Promise里的代码为什么比setTimeOut先执行
- 宏观任务：宿主发起。微观任务：JS引擎发起。微任务总是优先于宏任务执行
- 事件循环：“等待-执行”，每次执行都是一个宏观任务。
- 宏观任务栈中Promise产生的异步代码，需要在一个宏观任务内完成，由此出现宏观任务中存在一个微观任务栈
- Promise思想：异步操作函数不返回真是结果，返回一个“承诺”，等待合适的时机兑现承诺（Promise中的then方法的回调）
- 顺序：主线程任务>Promise中任务>.then回调中的任务>setTimeOut任务（按主>P>t）
- ```javascript
  console.log('a');
  setTimeout(() => {
    console.log("f")
  }, 1000)
  var r = new Promise(function (resolve, reject) {
    console.log('b');
    setTimeout(() => {
        console.log('g');
    }, 1000);
    resolve()
  });
  r.then(() => {
    console.log("c")
    new Promise(function (resolve, reject) {
        console.log('d');
        setTimeout(() => {
            console.log('h');
        }, 1000);
        resolve()
    }).then(() => console.log("e"))
  });
  ```
- ES6新特性：[async/await](https://segmentfault.com/a/1190000007535316)。async标识的函数必定返回Promise，返回Promise的函数为异步函数。
- await等到不是Promise对象，则直接为表达式结果。如果是Promise对象，则阻塞后续代码，等待Promise对象的resolve，再得到resolve的值。因为async异步，所以await阻塞不会造成主程序阻塞。await只能出现在async函数中。

### 闭包和执行上下文到底是怎么回事
- [闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)与普通函数的区别是携带执行环境（函数内部的子函数可以读取函数的局部变量）。
- 执行上下文
- 没有let的JS时代——立即执行的函数表达式（IIFE）
- [JS中的with](https://blog.csdn.net/zwkkkk1/article/details/79725934)很多情况下被规定禁止使用
- 会产生let使用的作用域：for, if, switch, try/catch/finally
- Realm(ES9)

### 你知道现在有多少种函数吗
- function定义的函数 function foo(){}
- 箭头函数 const foo = () => {}
- class中定义的函数 class C { foo(){} }
- function* 生成器函数 function* foo(){}
- class定义的类，实际也是函数 class Foo(){ constructor(){} }
- 异步函数：普通函数、箭头函数和生成器函数加上async关键字
- 函数都遵循“继承定义时环境”的规则
- [this关键字](https://juejin.cn/post/6844903805587619854)：调用函数时使用的引用，决定了函数执行时刻的this值。ES5的Reference类型
- this的内置函数 call(), apply(), bind()
- new操作。普通函数和类进行new操作会产生新对象，其余函数类型进行new操作都报错

### try里面放return，finally还会执行吗
- Completion类型。JS语句执行的完成状态，标准类型为：Completion Record（用于描述异常、跳出等语句执行过程）。表示一个语句执行完之后的结果，有三个字段：type, value, target
- type：表示完成的类型，有 break continue return throw 和 normal 几种类型
- value：表示语句的返回值，如果语句没有，则是 empty
- target：表示语句的目标，通常是一个 JavaScript 标签（配合break/continue）
- ```javascript
  function foo() {
    try { return 0; }
    catch (err) {}
    finally {
        console.log("a")
        return 1; // 注释后会执行return 0
    }
  }
  console.log(foo());
  ```
- 控制型语句会对不同类型的 Completion Record 产生反应。穿透、消费和报错应该是连贯的，“穿透”就是指不在当前这一层处理，向外逐层寻找可以“消费”的那一层，直到最后都没找到就报错
  ||break|continue|return|throw|
  |:-:|:-:|:-:|:-:|:-:|
  |if|穿透|穿透|穿透|穿透|
  |switch|消费|穿透|穿透|穿透|
  |for/while|消费|消费|穿透|穿透|
  |function|报错|报错|消费|穿透|
  |try|特殊处理|特殊处理|特殊处理|消费|
  |catch|特殊处理|特殊处理|特殊处理|穿透|
  |finally|特殊处理|特殊处理|特殊处理|穿透|

### 为什么12.toString会报错
- 词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”。
- JS源代码的输入分类：WhiteSpace 空白字符，LineTerminator 换行符，Comment 注释，Token 词（五类，如下）。
- IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。
- Punctuator 符号，我们使用的运算符和大括号等符号。
- NumericLiteral 数字直接量，就是我们写的数字。十进制的 Number 可以带小数，小数点前后部分都可以省略，但是不能同时省略：.01, 12, 12.01, 三者都是合法的数字直接量。但**12.toString会报错：Invalid or unexpected token**。12 .toString()和12..toString()则正常，**因为“12.”被看作了一个整体**
- StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。
- Template 字符串模板，用反引号` 括起来的直接量。
- 正则表达式直接量 RegularExpressionLiteral：正则表达式由 Body 和 Flags 两部分组成
### 理解编译原理：一个四则运算的解释器
- 定义四则运算：产出四则运算的词法定义和语法定义
- 词法分析：把输入的字符串流变成token（状态机或正则表达式）
- 语法分析：把token变成抽象语法树AST
- 解释执行：后续遍历AST，执行得出结果

### 到底要不要写分号
- 自动插入分号规则三条：有换行符，且下一个符号是不符合语法的；有换行符，且语法中规定此处不能有换行符；源代码结束处，不能形成完整的脚本或者模块结构。ps：带换行符的注释也被认为是有换行符
- ```javascript
  var a = 1, b = 1, c = 1;
  a
  ++ // 不可加分号
  b  // 可加分号
  ++
  c
  console.log(a, b, c); // 1 2 2
  ```
- no LineTerminator here 规则表示它所在的结构中的这一位置不能插入换行符。
  1. 带标签的continue/break语句，不能在continue/break后插入换行
  2. return后和yield之后，不能插入换行
  3. 后自增、后自减运算符前不能插入换行
  4. throw和Exception之间，不能插入换行
  5. 凡是async关键字，后面也不能插入换行
  6. 箭头函数的箭头前，不能插入换行
- 不写分号需要注意的情况：以括号开头的语句、以数组开头的语句、以正则表达式开头的语句、以Template开头的语句
- 引用尤雨溪说过的话：真正会导致上下行解析出问题的token有5个：括号，方括号，正则开头的斜杠，加号，减号。我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。哦当然再加个反引号。

### 在script标签写export为什么会抛错
- 脚本和模块：脚本具有主动性，模块更多是被动性等待调用（export）
- script标签中模块的引入\<script type="module" src="xx.js">\</script>，不加type默认为脚本
- ```javascript 
  import的用法
  1. import "mod"; // 引入一个模块
  2. import x from "mod"; // 把模块默认的导出值放入变量x
  3. import {a as x, modify} form "mod" // 引入模块中的变量
  4. import * as x from "mod" // 把模块中所有的变量以类似对象属性的方式引入
  5. import d, {a as x, modify} from "mod" // 2和3、4可组合
  ``` 
- ```javascript
  export的用法
  1. export {a, b, c} // 独立使用，export关键字+变量名列表
  2. export var d = 1/function(含async/generator)/class/let/const // export关键字+声明语句
  3. export default // 导出默认变量值，可用于function和class，导出的变量没有名称。使用import x from "xxx.js"导入
  4. var a = {}; export default a; // export+表达式。导出的为值，而不是引用，不会随当前模块里a的变化而变化
  ```
- 函数体：普通函数体function foo(){}、异步函数体async function foo(){}、生成器函数体function *foo(){}、异步生成器函数体async function *foo(){}
  |类型|yield|await|return|
  |:-:|:-:|:-:|:-:|
  |普通函数体|×|×|√|
  |异步函数体|×|√|√|
  |生产器函数体|√|×|√|
  |异步生产器函数体|√|√|√|
- JS预处理：变量提升、函数声明提升、类声明提升。前两个不会报错（undefined），类使用在声明前会报错。
- 指令序言机制：脚本和模块都支持，添加元信息。"use strict"，"no lint"。有点类似于Java的注解

### 你知道哪些JavaScript语句
- 
## HTML和CSS

## 浏览器实现原理与API

## 前端综合应用

## 后续

## 总结
