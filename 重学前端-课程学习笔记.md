# 重学前端|极客时间
## 前言

## JavaScript
### 关于类型,有哪些你不知道的细节
- 七大类型：Undefined、Null、Boolean、String、Number、Symbol（ES6）、Object。
- 用 void 0 代替 undefined，因为undefined是个变量可以被修改，void计算必定返回undefined
- String有最大长度是 2^53 - 1（UTF16编码）
- Number，IEEE规则，浮点运算精度问题，NaN、Infinity、-Infinity
- Object：是“属性的集合”
- new Number/String/Boolean/Symbol产生Obejct类型，而Number()/S/B/S则产生对应的类型
- Symbol
- JS对于数据转换。装箱转换和拆箱转换。
### 面向对象还是基于对象
- 对象是一种人类认知的高度抽象，JS对象具有高度的动态性
- 数据访问器：getter/setter
- 数据属性四个特征：value, writable, enumerable, configurable
- 定义属性：Object.defineProperty
- 查看属性：Object.getOwnPropertyDescriptor
### 我们真的需要模拟类吗
- JS使用了原型，复制的操作是使得新对象持有一个原型的引用
- JS原型的概括：1.如果所有对象都有私有字段 [[prototype]]，就是对象的原型。2.读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止(原型链)
- Object.create 根据指定的原型创建新对象，原型可以是 null
- Object.getPrototypeOf 获得一个对象的原型
- Object.setPrototypeOf 设置一个对象的原型
- JS中的new操作，两种方式：一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。
- ES6特性class。清除了所有[[class]]相关的私有属性，不会出现new和function搭配的奇怪操作。constructor, extends, getter/setter

### 你知道全部对象的分类吗
- 宿主对象：JS宿主环境提供，浏览器环境的宿主，window
- 内置对象：JS语言提供。固有对象，原生对象，普通对象
- 固有对象是JS代码执行前被创建，类似于基础库（api），“类”是其中一种
- 原生对象，能够通过语言本身的构造器创建的对象。new 创建，拥有许多私有字段。有：Error, Boolean, Number, Data等，无法用class/extend
- 函数对象与构造器对象
- ES6后 => 箭头函数仅用于创建函数，无法当作构造器
- 一些特殊行为的对象：Array, Object.prototype, String, Arguments等

### Promise里的代码为什么比setTimeOut先执行
- 宏观任务：宿主发起。微观任务：JS引擎发起。微任务总是优先于宏任务执行
- 事件循环：“等待-执行”，每次执行都是一个宏观任务。
- 宏观任务栈中Promise产生的异步代码，需要在一个宏观任务内完成，由此出现宏观任务中存在一个微观任务栈
- Promise思想：异步操作函数不返回真是结果，返回一个“承诺”，等待合适的时机兑现承诺（Promise中的then方法的回调）
- 顺序：主线程任务>Promise中任务>.then回调中的任务>setTimeOut任务（按主>P>t）
- ```javascript
  console.log('a');
  setTimeout(() => {
    console.log("f")
  }, 1000)
  var r = new Promise(function (resolve, reject) {
    console.log('b');
    setTimeout(() => {
        console.log('g');
    }, 1000);
    resolve()
  });
  r.then(() => {
    console.log("c")
    new Promise(function (resolve, reject) {
        console.log('d');
        setTimeout(() => {
            console.log('h');
        }, 1000);
        resolve()
    }).then(() => console.log("e"))
  });
  ```
- ES6新特性：[async/await](https://segmentfault.com/a/1190000007535316)。async标识的函数必定返回Promise，返回Promise的函数为异步函数。
- await等到不是Promise对象，则直接为表达式结果。如果是Promise对象，则阻塞后续代码，等待Promise对象的resolve，再得到resolve的值。因为async异步，所以await阻塞不会造成主程序阻塞。await只能出现在async函数中。

### 闭包和执行上下文到底是怎么回事
- [闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)与普通函数的区别是携带执行环境（函数内部的子函数可以读取函数的局部变量）。
- 执行上下文
- 没有let的JS时代——立即执行的函数表达式（IIFE）
- [JS中的with](https://blog.csdn.net/zwkkkk1/article/details/79725934)很多情况下被规定禁止使用
- 会产生let使用的作用域：for, if, switch, try/catch/finally
- Realm(ES9)

### 你知道现在有多少种函数吗
- function定义的函数 function foo(){}
- 箭头函数 const foo = () => {}
- class中定义的函数 class C { foo(){} }
- function* 生成器函数 function* foo(){}
- class定义的类，实际也是函数 class Foo(){ constructor(){} }
- 异步函数：普通函数、箭头函数和生成器函数加上async关键字
- 函数都遵循“继承定义时环境”的规则
- [this关键字](https://juejin.cn/post/6844903805587619854)：调用函数时使用的引用，决定了函数执行时刻的this值。ES5的Reference类型
- this的内置函数 call(), apply(), bind()
- new操作。普通函数和类进行new操作会产生新对象，其余函数类型进行new操作都报错

### try里面放return，finally还会执行吗
- Completion类型。JS语句执行的完成状态，标准类型为：Completion Record（用于描述异常、跳出等语句执行过程）。表示一个语句执行完之后的结果，有三个字段：type, value, target
- type：表示完成的类型，有 break continue return throw 和 normal 几种类型
- value：表示语句的返回值，如果语句没有，则是 empty
- target：表示语句的目标，通常是一个 JavaScript 标签（配合break/continue）
- ```javascript
  function foo() {
    try { return 0; }
    catch (err) {}
    finally {
        console.log("a")
        return 1; // 注释后会执行return 0
    }
  }
  console.log(foo());
  ```
- 控制型语句会对不同类型的 Completion Record 产生反应。穿透、消费和报错应该是连贯的，“穿透”就是指不在当前这一层处理，向外逐层寻找可以“消费”的那一层，直到最后都没找到就报错
  ||break|continue|return|throw|
  |:-:|:-:|:-:|:-:|:-:|
  |if|穿透|穿透|穿透|穿透|
  |switch|消费|穿透|穿透|穿透|
  |for/while|消费|消费|穿透|穿透|
  |function|报错|报错|消费|穿透|
  |try|特殊处理|特殊处理|特殊处理|消费|
  |catch|特殊处理|特殊处理|特殊处理|穿透|
  |finally|特殊处理|特殊处理|特殊处理|穿透|

### 为什么12.toString会报错
- 词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”。
- JS源代码的输入分类：WhiteSpace 空白字符，LineTerminator 换行符，Comment 注释，Token 词（五类，如下）。
- IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。
- Punctuator 符号，我们使用的运算符和大括号等符号。
- NumericLiteral 数字直接量，就是我们写的数字。十进制的 Number 可以带小数，小数点前后部分都可以省略，但是不能同时省略：.01, 12, 12.01, 三者都是合法的数字直接量。但**12.toString会报错：Invalid or unexpected token**。12 .toString()和12..toString()则正常，**因为“12.”被看作了一个整体**
- StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。
- Template 字符串模板，用反引号` 括起来的直接量。
- 正则表达式直接量 RegularExpressionLiteral：正则表达式由 Body 和 Flags 两部分组成
### 理解编译原理：一个四则运算的解释器
- 定义四则运算：产出四则运算的词法定义和语法定义
- 词法分析：把输入的字符串流变成token（状态机或正则表达式）
- 语法分析：把token变成抽象语法树AST
- 解释执行：后续遍历AST，执行得出结果

### 到底要不要写分号
- 自动插入分号规则三条：有换行符，且下一个符号是不符合语法的；有换行符，且语法中规定此处不能有换行符；源代码结束处，不能形成完整的脚本或者模块结构。ps：带换行符的注释也被认为是有换行符
- ```javascript
  var a = 1, b = 1, c = 1;
  a
  ++ // 不可加分号
  b  // 可加分号
  ++
  c
  console.log(a, b, c); // 1 2 2
  ```
- no LineTerminator here 规则表示它所在的结构中的这一位置不能插入换行符。
  1. 带标签的continue/break语句，不能在continue/break后插入换行
  2. return后和yield之后，不能插入换行
  3. 后自增、后自减运算符前不能插入换行
  4. throw和Exception之间，不能插入换行
  5. 凡是async关键字，后面也不能插入换行
  6. 箭头函数的箭头前，不能插入换行
- 不写分号需要注意的情况：以括号开头的语句、以数组开头的语句、以正则表达式开头的语句、以Template开头的语句
- 引用尤雨溪说过的话：真正会导致上下行解析出问题的token有5个：括号，方括号，正则开头的斜杠，加号，减号。我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。哦当然再加个反引号。

### 在script标签写export为什么会抛错
- 脚本和模块：脚本具有主动性，模块更多是被动性等待调用（export）
- script标签中模块的引入\<script type="module" src="xx.js">\</script>，不加type默认为脚本
- ```javascript 
  import的用法
  1. import "mod"; // 引入一个模块
  2. import x from "mod"; // 把模块默认的导出值放入变量x
  3. import {a as x, modify} form "mod" // 引入模块中的变量
  4. import * as x from "mod" // 把模块中所有的变量以类似对象属性的方式引入
  5. import d, {a as x, modify} from "mod" // 2和3、4可组合
  ``` 
- ```javascript
  export的用法
  1. export {a, b, c} // 独立使用，export关键字+变量名列表
  2. export var d = 1/function(含async/generator)/class/let/const // export关键字+声明语句
  3. export default // 导出默认变量值，可用于function和class，导出的变量没有名称。使用import x from "xxx.js"导入
  4. var a = {}; export default a; // export+表达式。导出的为值，而不是引用，不会随当前模块里a的变化而变化
  ```
- 函数体：普通函数体function foo(){}、异步函数体async function foo(){}、生成器函数体function *foo(){}、异步生成器函数体async function *foo(){}
  |类型|yield|await|return|
  |:-:|:-:|:-:|:-:|
  |普通函数体|×|×|√|
  |异步函数体|×|√|√|
  |生产器函数体|√|×|√|
  |异步生产器函数体|√|√|√|
- JS预处理：变量提升、函数声明提升、类声明提升。前两个不会报错（undefined），类使用在声明前会报错。
- 指令序言机制：脚本和模块都支持，添加元信息。"use strict"，"no lint"。有点类似于Java的注解

### 你知道哪些JavaScript语句
- 语句块，会产生作用域
- 空语句，一个独立分号。为了语言设计完备性，允许多个分号不会抛错，没大用
- if语句，if-else
- switch语句，类似于if-else语句，在JS中，性能上与if-else无区别
- 循环语句：while和do-while，区别是do-while会先执行do语句块内容再执行while循环
- 循环语句：for, 普通的通过变量控制循环。for-in, 枚举对象属性，体现了属性的enumerable特征。for-of, 底层机制是iterator，我们可以给任何对象添加iterator并使用for of语句。for-await-of, 一个异步循环
- return语句，终止函数执行，返回函数指定的值
- break语句和continue语句，break语句跳出循环。continue语句终止本次循环，进入下一次
- with语句，把对象的属性在它内部的作用域内变成变量（同时把JS变量间的引用关系变得不可分析）
- try语句和thorw语句，try捕获异常，thorw语句用于抛出错误。catch做捕获异常后的一些处理，通常重新抛出错误，目的为了错误能够被理解。finally用于释放资源，它一定会被执行
- debugger语句，通知调试器在此断点。在没有调试器挂载时，它不产生任何效果
- var, let, const, class声明, 函数声明：预处理机制和作用块

### 什么是表达式语句
- PrimaryExpression 主要表达式，表达式的原子项、最小单位，语法结构优先级最高
- MemberExpression 成员表达式，通常用于访问对象成员
- NewExpression New表达式，MemberExpression加上new就是NewExpression
- CallExpression 函数调用表达式，一般形式魏MenberExpression后加一个括号里的参数列表
- LeftHandSideExpresion 左值表达式，NewExpression和CallExpression的统称
- AssignmentExpression 赋值表达式，基本形态为等号赋值

### 新加入的**运算符，哪里有些不一样呢
- JS标准中不存在右值表达式。其他语言中右值表达式的概念在JS统一称为条件表达式
- 更新表达式 UpdateExpression，前后自增自减（ES2018后优先级相同）
- 一元运算表达式 UnaryExpression，如：void a; typeof a;!a
- 乘方表达式 ExponentiationExpression，右结合。4\*\*3\*\*2等同4\*\*(3\*\*2)。-2\*\*30 //报错
- 乘法表达式 MultiplicativeExpression，符号：*, /, %
- 加法表达式 AdditiveExpression，符号：+, -
- 移位表达式 ShiftExpression，左移位：<<, 右移位：>>, 无符号向右移位：>>>
- 关系表达式是 RelationalExpression，符号：<=, >=, <, >, instanceof, in
- 相等表达式 EqualityExpression，符号：==, !=, \=\=\=, \!\=\=。==符号的规则复杂，包含类型转换的知识。
- 位运算表达式，按位与 &、按位异或 ^、按位或 |。
- 逻辑与（&&）表达式和逻辑或（||）表达式。逻辑表达式的短路特点。
- 条件表达式 ConditionalExpression，三木运算符 condition ? branch1:branch2

## HTML和CSS

## 浏览器实现原理与API

## 前端综合应用

## 后续

## 总结
