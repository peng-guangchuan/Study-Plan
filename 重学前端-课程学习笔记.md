# 重学前端|极客时间
## 前言

## JavaScript
### 关于类型,有哪些你不知道的细节
- 七大类型：Undefined、Null、Boolean、String、Number、Symbol（ES6）、Object。
- 用 void 0 代替 undefined，因为undefined是个变量可以被修改，void计算必定返回undefined
- String有最大长度是 2^53 - 1（UTF16编码）
- Number，IEEE规则，浮点运算精度问题，NaN、Infinity、-Infinity
- Object：是“属性的集合”
- new Number/String/Boolean/Symbol产生Obejct类型，而Number()/S/B/S则产生对应的类型
- Symbol
- JS对于数据转换。装箱转换和拆箱转换。
### 面向对象还是基于对象
- 对象是一种人类认知的高度抽象，JS对象具有高度的动态性
- 数据访问器：getter/setter
- 数据属性四个特征：value, writable, enumerable, configurable
- 定义属性：Object.defineProperty
- 查看属性：Object.getOwnPropertyDescriptor
### 我们真的需要模拟类吗
- JS使用了原型，复制的操作是使得新对象持有一个原型的引用
- JS原型的概括：1.如果所有对象都有私有字段 [[prototype]]，就是对象的原型。2.读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止(原型链)
- Object.create 根据指定的原型创建新对象，原型可以是 null
- Object.getPrototypeOf 获得一个对象的原型
- Object.setPrototypeOf 设置一个对象的原型
- JS中的new操作，两种方式：一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。
- ES6特性class。清除了所有[[class]]相关的私有属性，不会出现new和function搭配的奇怪操作。constructor, extends, getter/setter

### 你知道全部对象的分类吗
- 宿主对象：JS宿主环境提供，浏览器环境的宿主，window
- 内置对象：JS语言提供。固有对象，原生对象，普通对象
- 固有对象是JS代码执行前被创建，类似于基础库（api），“类”是其中一种
- 原生对象，能够通过语言本身的构造器创建的对象。new 创建，拥有许多私有字段。有：Error, Boolean, Number, Data等，无法用class/extend
- 函数对象与构造器对象
- ES6后 => 箭头函数仅用于创建函数，无法当作构造器
- 一些特殊行为的对象：Array, Object.prototype, String, Arguments等

### Promise里的代码为什么比setTimeOut先执行
- 宏观任务：宿主发起。微观任务：JS引擎发起。微任务总是优先于宏任务执行
- 事件循环：“等待-执行”，每次执行都是一个宏观任务。
- 宏观任务栈中Promise产生的异步代码，需要在一个宏观任务内完成，由此出现宏观任务中存在一个微观任务栈
- Promise思想：异步操作函数不返回真是结果，返回一个“承诺”，等待合适的时机兑现承诺（Promise中的then方法的回调）
- 顺序：主线程任务>Promise中任务>.then回调中的任务>setTimeOut任务（按主>P>t）
- ```javascript
  console.log('a');
  setTimeout(() => {
    console.log("f")
  }, 1000)
  var r = new Promise(function (resolve, reject) {
    console.log('b');
    setTimeout(() => {
        console.log('g');
    }, 1000);
    resolve()
  });
  r.then(() => {
    console.log("c")
    new Promise(function (resolve, reject) {
        console.log('d');
        setTimeout(() => {
            console.log('h');
        }, 1000);
        resolve()
    }).then(() => console.log("e"))
  });
  ```
- ES6新特性：[async/await](https://segmentfault.com/a/1190000007535316)。async标识的函数必定返回Promise，返回Promise的函数为异步函数。
- await等到不是Promise对象，则直接为表达式结果。如果是Promise对象，则阻塞后续代码，等待Promise对象的resolve，再得到resolve的值。因为async异步，所以await阻塞不会造成主程序阻塞。await只能出现在async函数中。

### 闭包和执行上下午到底是怎么回事
- [闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)与普通函数的区别是携带执行环境（函数内部的子函数可以读取函数的局部变量）。
- 执行上下文
- 没有let的JS时代——立即执行的函数表达式（IIFE）
- [JS中的with](https://blog.csdn.net/zwkkkk1/article/details/79725934)很多情况下被规定禁止使用
- 会产生let使用的作用域：for, if, switch, try/catch/finally
- Realm(ES9)
## HTML和CSS

## 浏览器实现原理与API

## 前端综合应用

## 后续

## 总结
